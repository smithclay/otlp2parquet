# otlp2parquet with MinIO - S3-compatible local storage
# One command: docker-compose up

services:
  # MinIO - S3-compatible object storage
  minio:
    image: minio/minio:latest
    ports:
      - "${MINIO_API_PORT:-9000}:9000"
      - "${MINIO_CONSOLE_PORT:-9001}:9001"
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER:-minioadmin}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD:-minioadmin}
    volumes:
      - minio-data:/data
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

  # Create bucket automatically
  minio-init:
    image: minio/mc:latest
    depends_on:
      minio:
        condition: service_healthy
    entrypoint: >
      /bin/sh -c "
      /usr/bin/mc alias set myminio http://minio:9000 ${MINIO_ROOT_USER:-minioadmin} ${MINIO_ROOT_PASSWORD:-minioadmin};
      /usr/bin/mc mb myminio/${S3_BUCKET:-otlp-logs} --ignore-existing;
      /usr/bin/mc anonymous set download myminio/${S3_BUCKET:-otlp-logs};
      echo 'MinIO bucket ready';
      "

  # Iceberg REST catalog
  nessie:
    image: ghcr.io/projectnessie/nessie:latest
    ports:
      - "19120:19120"  # API port
      - "9002:9000"    # Management port (health checks) - mapped to 9002 to avoid MinIO conflict
    depends_on:
      minio:
        condition: service_healthy
    environment:
      # Use property names directly (Quarkus MicroProfile Config style)
      nessie.version.store.type: "IN_MEMORY"
      quarkus.http.port: "19120"
      quarkus.profile: "iceberg-rest"
      # Warehouse configuration
      nessie.catalog.default-warehouse: "warehouse"
      nessie.catalog.warehouses.warehouse.location: "s3://otlp-logs/warehouse"
      # S3 default options
      nessie.catalog.service.s3.default-options.region: "us-east-1"
      nessie.catalog.service.s3.default-options.path-style-access: "true"
      nessie.catalog.service.s3.default-options.endpoint: "http://minio:9000/"
      # Credential configuration using URN pattern (Nessie's secret management)
      nessie.catalog.service.s3.default-options.access-key: "urn:nessie-secret:quarkus:nessie.catalog.secrets.access-key"
      nessie.catalog.secrets.access-key.name: "${AWS_ACCESS_KEY_ID:-minioadmin}"
      nessie.catalog.secrets.access-key.secret: "${AWS_SECRET_ACCESS_KEY:-minioadmin}"
    healthcheck:
      test: "exec 3<>/dev/tcp/localhost/9000 && echo -e 'GET /q/health HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n' >&3 && cat <&3 | grep -q '200 OK'"
      interval: 5s
      timeout: 2s
      retries: 15

  # Create Iceberg namespace automatically
  nessie-init:
    image: curlimages/curl:latest
    depends_on:
      nessie:
        condition: service_healthy
    entrypoint: >
      /bin/sh -c "
      curl -X POST http://nessie:19120/iceberg/v1/main/namespaces \
        -H 'Content-Type: application/json' \
        -d '{\"namespace\": [\"otlp\"], \"properties\": {}}' || true;
      echo 'Nessie namespace ready';
      "

  # otlp2parquet
  otlp2parquet:
    # image: ghcr.io/smithclay/otlp2parquet:latest
    # For local development:
    build: .
    depends_on:
      minio:
        condition: service_healthy
      minio-init:
        condition: service_completed_successfully
      nessie:
        condition: service_healthy
      nessie-init:
        condition: service_completed_successfully
    ports:
      - "${HTTP_PORT:-4318}:4318"
    environment:
      # Storage (override for cloud: OTLP2PARQUET_STORAGE_BACKEND=s3 OTLP2PARQUET_S3_ENDPOINT= OTLP2PARQUET_S3_REGION=us-east-1)
      OTLP2PARQUET_STORAGE_BACKEND: ${STORAGE_BACKEND:-s3}
      OTLP2PARQUET_S3_BUCKET: ${S3_BUCKET:-otlp-logs}
      OTLP2PARQUET_S3_REGION: ${S3_REGION:-us-east-1}
      OTLP2PARQUET_S3_ENDPOINT: ${S3_ENDPOINT:-http://minio:9000}

      # Credentials (override for cloud: AWS_ACCESS_KEY_ID=xxx AWS_SECRET_ACCESS_KEY=xxx)
      AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID:-minioadmin}
      AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY:-minioadmin}

      # Server (OTLP HTTP port)
      OTLP2PARQUET_HTTP_PORT: 4318
      OTLP2PARQUET_HTTP_HOST: 0.0.0.0
      RUST_LOG: ${RUST_LOG:-info}

      # Batching (disable for tests to get immediate writes)
      OTLP2PARQUET_BATCHING_ENABLED: ${BATCHING_ENABLED:-false}

      # Iceberg catalog (optional - enables Nessie integration)
      OTLP2PARQUET_ICEBERG_ENABLED: ${ICEBERG_ENABLED:-true}
      OTLP2PARQUET_ICEBERG_REST_URI: ${ICEBERG_REST_URI:-http://nessie:19120/iceberg}
      OTLP2PARQUET_ICEBERG_WAREHOUSE: ${ICEBERG_WAREHOUSE:-s3://otlp-logs/warehouse}
      OTLP2PARQUET_ICEBERG_NAMESPACE: ${ICEBERG_NAMESPACE:-otlp}

    restart: unless-stopped
    # Note: healthcheck removed because distroless image has no wget/curl
    # The test-e2e.sh script handles health checking from the host

  # Telemetrygen - Generate sample OTLP logs, metrics, and traces
  telemetrygen-traces:
    image: ghcr.io/open-telemetry/opentelemetry-collector-contrib/telemetrygen:latest
    depends_on:
      - otlp2parquet
    command:
      - traces
      - --otlp-endpoint=otlp2parquet:4318
      - --otlp-http
      - --otlp-insecure
      - --duration=inf  # Run continuously
      - --rate=2        # 2 spans per second
      - --service=telemetrygen-traces
      - --status-code=Ok
    restart: unless-stopped

  telemetrygen-metrics:
    image: ghcr.io/open-telemetry/opentelemetry-collector-contrib/telemetrygen:latest
    depends_on:
      - otlp2parquet
    command:
      - metrics
      - --otlp-endpoint=otlp2parquet:4318
      - --otlp-http
      - --otlp-insecure
      - --duration=inf  # Run continuously
      - --rate=2        # 2 metrics per second
      - --service=telemetrygen-metrics
    restart: unless-stopped

  telemetrygen-logs:
    image: ghcr.io/open-telemetry/opentelemetry-collector-contrib/telemetrygen:latest
    depends_on:
      - otlp2parquet
    command:
      - logs
      - --otlp-endpoint=otlp2parquet:4318
      - --otlp-http
      - --otlp-insecure
      - --duration=inf  # Run continuously
      - --rate=2        # 2 logs per second
      - --service=telemetrygen-logs
    restart: unless-stopped

volumes:
  minio-data:

# Usage:
#
# Local (MinIO):
#   docker-compose up
#   OTLP endpoint: http://localhost:4318/v1/logs (OpenTelemetry HTTP)
#   MinIO console: http://localhost:9001 (minioadmin/minioadmin)
#
# AWS S3:
#   STORAGE_BACKEND=s3 S3_REGION=us-east-1 AWS_ACCESS_KEY_ID=xxx AWS_SECRET_ACCESS_KEY=xxx docker-compose up
#
# Cloudflare R2:
#   STORAGE_BACKEND=s3 S3_ENDPOINT=https://ACCOUNT_ID.r2.cloudflarestorage.com AWS_ACCESS_KEY_ID=xxx AWS_SECRET_ACCESS_KEY=xxx docker-compose up
#
# Query with DuckDB:
#   duckdb -c "INSTALL httpfs; LOAD httpfs;
#   SET s3_endpoint='localhost:9000'; SET s3_url_style='path'; SET s3_use_ssl=false;
#   SET s3_access_key_id='minioadmin'; SET s3_secret_access_key='minioadmin';
#   SELECT * FROM read_parquet('s3://otlp-logs/logs/**/*.parquet') LIMIT 10;"
